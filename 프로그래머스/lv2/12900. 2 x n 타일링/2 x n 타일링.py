from itertools import combinations
import math

def solution(n):
    
    # 이런 문제는 패턴이 있는데 그걸 발견하면 됨.
    
    # 세로의 길이가 2이고, 가로의 길이가 n인 바닥을 가득 채우려면
    # 가로로 직사각형 두는 것의 max 갯수는 n이 짝수면 n/2개, n이 홀수면 n//2개 - 홀수든 짝수든 n//2개 -> 가로의 갯수 0~max개까지 경우의 수 탐색하면 되고,
    
    # 예시보면 n=4면,
    # 가로 갯수 0일 때, 1일 때, 2일 때 (n//2=2)
    # 0일 때 1, 1일 때 3, 2일 때 1 = 합 5 // 길이 4를 2로 채우는 경우의 수 3 
    
    # **n=7 - 1=> 콤비네이션이랑 같지않나? 7개의 구슬중에 2개 고르는 건데, 2개가 붙어있어야 하네
    # 이러면 2로 나눠주는 경우의 수네.
    
    
    
    # n=3
    # 가로 0, 1 가로 1, 2  = 3  // 3을 2로 나누는 몫 + 나머지가 경우의 수?
#     answer = 0
    
#     max_garo = n//2
    
#     for i in range(0,max_garo+1): # 가로의 갯수마다 경우의 수 구하기로 함. 로직은 i==0이면 1이고, 가로가 max_garo로 완전히 나눠지는 경우도 1이고, 나머지는 조합인데 붙어다니는 경우의 수니까 나눠주기
#         if i==0:
#             answer+=1
#         elif n%2==0 and n == max_garo:
#             answer+=1
#         else:
#             answer+=math.factorial(n) // (math.factorial(n-i)*math.factorial(i)*math.factorial(i))        
#------------------------------------------------
    # 풀이법 : 동적 계획법
    # 동적 계획법의 핵심은 점화식을 찾는 것.
    # ex) n=1 : 1.... ->1
    # ex) n=2 : 11, 2 ->2
    # ex) n=3 : 111, 21,12 -> 3
    # ex) n=4 : 1111, 211, 112, 121, 22 -> 5
    
    # dp[3] = 3 = dp[1] + dp[2]
    # dp[4] = 5 = dp[2] + dp[3] --- 이렇게 패턴이 나오는 게 점화식이라고 함.
    # 예시 나온 걸 기준으로 n=1부터 하나씩 올려가면서 점화식을 찾는 문제였음.
    
    # 주의할 점 : 새로운 dp 값을 넣을 때 매번 1,000,000,007으로 나눠주어야 시간초과가 발생하지 않는다.
    
    dp = [0 for i in range(n)] # dp에 n의 갯수에 따라 [0] 갯수를 넣어줘라.
                               # dp[n] = 값을 저장하기 위해 0으로 초기값 설정한듯함.
    dp[0], dp[1] = 1,2 # dp[0]이 n=1일 때, dp[1]이 n=2일 때 -- 인덱스 번호는 바꿀 수 없어서 0부터 설정해둬야 되나봐
    for i in range(2,n):
        dp[i] = (dp[i-1] + dp[i-2]) % 1000000007
    
    return dp[n-1]
# dp를 왜 0부터 해야 list out of range가 안되지?