def solution(n):
    
    # 에라토스테네스의 체
    
    # 배열을 생성하여 값을 초기화
    # 2부터 시작해서 특정 숫자의 배수에 해당하는 숫자들은  모두 지운다. (예를들어 2의 배수에 해당하는 숫자를 지운다면 2를 제외한 모든 수를 지우는 것)
    # 이미 지워진 숫자의 경우 건너 뛴다.
    # 2부터 시작하여 남아있는 숫자들을 출력.
    
    answer = 0
    array = [True for i in range(n+1)]
    # 배열 생성하여 모든 수가 소수인 것으로 초기화.
    # **약수의 성질에 따라 가운데 약수(제곱근)까지만 확인해도 됨
        # 2 * 4 = 8  4 * 2 = 8처럼 약수는 대칭을 이루기에
    for i in range(2,int(n**(1/2))+1):
        if array[i] == True: # i가 소수면
            # 특정 숫자의 배수에 해당하는 숫자들을 지운다.
            j = 2
            while i*j <= n: # n보다 같거나 작은 배수들 전부 지워주는 과정
                array[i*j] = False
                # array는 어차피 0부터 시작인 배열이라 이렇게 해도 인덱싱이 맞네
                j += 1
    for i in range(2,n+1):
        if array[i]:
            answer += 1 # 남아 있는 숫자들 개수를 세준다.
            
    return answer

        
# 숫자를 2부터 숫자의 제곱근까지 나눠봐서 하나라도 나뉘어 떨어지는지 확인하면 됩니다.
# 끝까지 나누지 않고 제곱근까지 나눠도 소수를 판별할 수 있는 이유는
# 숫자의 약수는 숫자의 제곱근 범위에 존재하기 때문입니다.
# 예시로 숫자가 12일 때 2 x 6, 3 x 4, 4 x 3, 6 x 2로 표현되고
# 몫이 커지면 나누는 값이 작아지거나, 나누는 값이 커지면 몫이 작아지는 반비례 관계입니다.
# 즉, 제곱근까지 나누어보면 이후에는 몫과 나누는 값이 반대로 바뀌는 경우밖에 없으므로
# 굳이 나누어보지 않아도 됩니다.
